---
title: "Siland: Spatial Influence of Landscape"
author : "Florence Carpentier and Olivier Martin"
date: "`r Sys.Date()`" 
output: 
 html_document:
    fig_caption: false
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 3
    


vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
  
---

```{r echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse=T,
                      cache=T,
                      eval = FALSE)

#knitr::opts_chunk$set(eval = FALSE)
# options(width = 120, max.print = 100)
```




## Introduction

The package _siland_ aims to estimate the scale and the shape of influence for landscape variables on measurements. Two methods are available. The first one (Bsiland()) is based on buffer computing around location of obserevd data. Landscape descritpion uses GIS
files thanks sf objects, and GIS files can be loaded in R with the function st_read() in the package sf. The second one (Fsiland()) is based on estimation of Spatial Influence Functions (SIF). Landscape descritpion is also based on sig files, but a raster discretisation is performed to estimate parameters associated to SIFs. For this reason, it would be possible to pass directly a rast er for landscape description rather than a sf object (this possibility is not yet implemented). The SIF function describes how the influence of a pixel/cell in the landscape decreases with the distance from the locations of observed data. 

## Data example

To illustrate the functions Bsiland() and Fsiland(), we use a toy example with objects dataSiland and landSiland.
The object for observations has to be a dataframe and locations have to be indicated in columns "X" and "Y". Concerning dataframe dataSiland, the observed variable is "obs" and variable "x1" is a continuous local variable. Column "Id" gives the identification number of the field where observations were made.
The object landSiland gives the landscape description and is an object of class sf. The landscape is characterised by two features, named L1 and L2. 


```{r}
library(siland)
data(dataSiland)
class(dataSiland)
data(landSiland)
class(landSiland)
```

In this example, varibales L1 and L2 can be associated to land uses. So, landSiland\$L1 and landSiland\$L2 are vectors with 1 and 0 values. Value 1 simply indicates when landscape variables are observed for each polygon, and 0 otherwise.

```{r fig.align='center',fig.width=7}
par(mai=c(0,0,0,0),mar=c(0,0,0,0))
plot(landSiland$geometry,border=gray(0.6))
sel=landSiland$L1==1
plot(st_geometry(landSiland[sel,]),add=T,col=2)
sel=landSiland$L2==1
plot(st_geometry(landSiland[sel,]),add=T,col=3)
points(dataSiland[,c("X","Y")],pch=16,col=4)
```


## Approach Bsiland()

Estimating a gaussian model with local varibale x1 and landscape variables L1 and L2 with Bsiland() can be done with the command:

```{r }
resB1=Bsiland(obs~x1+L1+L2,land=landSiland,data=dataSiland,family=gaussian)
resB1
summary(resB1)
```
Note that pvalues given in the summary correpond to pvalues for 
a model conditionnaly to the estimated buffer sizes.  resB1\$parambuffer  gives 
the estimated distances for buffers and resB1$buffer gives the associated percentages for each observation.

```{r }
resB1$parambuffer
```
The argument border=F (by default) in function Bsiland indicates that buffer are computed from the locations of observations. The option border=T allows to estimate the buffer sizes from the border of the polygon (field) where observations are made.

```{r }
resB2=Bsiland(obs~x1+L1+L2,land=landSiland,data=dataSiland,family=gaussian,border=T)
resB2$parambuffer
```

Graphical representation of estimations is done with plotBsiland.land() function. The color intensity is the result of the product of the buffer and the associated coeffcient for each landscape variable. One can see the difference between border=F and border=T with the following graphics.

```{r fig.align='center',fig.width=7}
plotBsiland.land(x=resB1,land=landSiland,data=dataSiland,var=2)
```
```{r fig.align='center',fig.width=7}
plotBsiland.land(x=resB2,land=landSiland,data=dataSiland,var=2)
```
s
The function Bsiand.lik() allows to point out possible problems of optimization.
```{r fig.align='center',fig.width=7}
Bsiland.lik(resB1,land= landSiland, data=dataSiland,varnames=c("L1","L2"))
```

On this graphic, the orange line indicates the opposite of the log-likelihood associated to the estimated model. One observes that by varying buffer sizes for variables "L1" and "L2", the opposite log-likelihhod is still above the estimated one. This indicates that the maximisation of log-likelihood (or minimisation of the opposite of log-likelihood) seems to have occured correcly. Otherwise, it is necessary to proceed new estimation by changing point initialisation for optimisation procedure. This is possible thanks the argument init in function Bsiland.

## Approach Fsiland()

Approach Fsiland() works in a very similar way:
```{r }
resF1=Fsiland(obs~x1+L1+L2,land=landSiland,data=dataSiland,family=gaussian, sif="exponential",wd=50)
resF1
summary(resF1)
```

The argument sif defines the form of the decrease for the landscape influence in raster. The form can be "exponential" or "gaussian". It is also possible to specify an "uniform" influence around each pixel of the raster. Note that all landscape variables have the same form. One can compare the different estimated FISs for landscape variables with the command:

```{r fig.align='center',fig.width=7}
plotFsiland.sif(resF1)
```


Argument wd indicates the size of each pixel in raster. It is important to note that estimated parameters are sensitive to this size. We recommand to ensure that size for wd is  three times smaller than the smallest estimated SIF. If not, it is recommended to proceed a new estimation by changing the wd size.

The objects resF1\$SIF and resF1\$landcontri give the SIF estimated and the landscape contributions for the different variables. The argument border indicates if  pixels inside polygon where observations were made have to be take into account (border = F by default) or not (border=T).

By indicating the number of variable with  the argument var, graphical representation is done with plotFsiland.land() function:
```{r fig.align='center',fig.width=7}
plotFsiland.land(x=resF1,land=landSiland,data=dataSiland,var=2)
```
By indicating var=0 (by default), the function plotFsiland.land() gives the sum of contributions on all landscape variables:

```{r fig.align='center',fig.width=7}
plotFsiland.land(x=resF1,land=landSiland,data=dataSiland)
```



## Comparison between Fsiland() and Bsiland()

A simple comparison of the two approaches can be made by comparing the two dataframes resB1\$buffer and resF1\$landcontri.

```{r fig.align='center',fig.width=7}
par(mfrow=c(1,2))
plot(resB1$buffer[,1],resF1$landcontri[,1],xlab="buffer",ylab="land contri.")
abline(0,1)
plot(resB1$buffer[,2],resF1$landcontri[,2],xlab="buffer",ylab="land contri.")
abline(0,1)
```


## Model with random effects

It is possible to use models with random effects.

```{r }
resB3=Bsiland(obs~x1+L1+L2+(1|Id),land=landSiland,data=dataSiland,family=gaussian)
summary(resB3)
resF3=Fsiland(obs~x1+L1+L2+(1|Id),land=landSiland,data=dataSiland,family=gaussian)
summary(resF3)
```

## Model with interaction between local and landscape variables

It is possible to use models with interaction between local and landscape variables. If there are an interaction term and a main effect, the distance is supposed the same for the two parts.

```{r }
#Model with main and interaction effect
resF4=Fsiland(obs~x1*L1+L2,land=landSiland,data=dataSiland,family=gaussian)
#Model with only interaction effect
resF5=Fsiland(obs~x1:L1+L2,land=landSiland,data=dataSiland,family=gaussian)

```
The same syntax can be applied with function Bsiland().

## Model with several years

Let us suppose we have two years of observations associated to two landscapes. Since the goal is only to show how to deal with such datasets,  we take the same datastets for observations and for landscape for the two years.

```{r }
landSilandY1=landSiland
landSilandY2=landSiland
#landSilandY is a list with the landscape for each year
landSilandY=list(landSilandY1,landSilandY2)
dataSilandY1=dataSiland
dataSilandY2=dataSiland
dataSilandY1$year=factor("2018")
dataSilandY2$year=factor("2019")
colnames(dataSilandY1)
colnames(dataSilandY2)
head(dataSilandY1)
head(dataSilandY2)
dataSilandY=list(dataSilandY1,dataSilandY2)
```
An important point is that colnames for dataSilandY1 and dataSilandY2 have to be exactly the same, and ordred in the same way. Then, it is possible to estimate a model wih Bsiland()

```{r }
resY=Bsiland(obs~year+x1+L1+L2, land = landSilandY,data=dataSilandY)
resY
summary(resY)
```

Note this solution can also be used to analyse set of datasets with different landscapes. Concerning Fsiland() function, it is not yet possible to use such approaches.

## Remarks

As for an object ot type GLM, functions AIC(), residuals() and fitted() are available. In fact, conditionnaly to the estimated buffer or SIF, the fitted model  is a GLM or LMM (Linear Mixed Model) or GLMM (Generalized Linear Mixed Model). So after an estimation with Bsiland or Fsiland(), it is possible to analyse more precisely the estimated model with the object result stored in the output. Object result is an an object from glm() or lmer() or glmer() functions.

```{r }
summary(resB1$result)
BIC(resB1$result)
fitted(resF1$result)[1:10]
residuals(resF1$result)[1:10]
class(resB1$result)
class(resF1$result)

```



